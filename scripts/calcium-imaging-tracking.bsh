


img = ij.IJ.getImage();
width = img.getWidth();
height = img.getHeight();
roi = img.getRoi();
ip = img.getProcessor();
ipCropped = ip.crop();
imgCropped = new ij.ImagePlus("cropped", ipCropped);


// segmentation
imgStats = imgCropped.getStatistics(ij.measure.Measurements.MEAN);
mean = imgStats.mean;
ipBgSubtracted = imgCropped.getProcessor().duplicate();
//ipBgSubtracted.add(-mean * 0.5);
rf = new ij.plugin.filter.RankFilters();
rf.rank(ipBgSubtracted, 0.0, ij.plugin.filter.RankFilters.MEDIAN);
ipBgSubtracted.autoThreshold();


// show segmented image
imgBgSubtracted = new ij.ImagePlus("subtracted", ipBgSubtracted);
bgSubtractedImgStats = imgBgSubtracted.getStatistics(ij.measure.Measurements.CENTROID + ij.measure.Measurements.CENTER_OF_MASS);


centerOfMassPt = new ij.gui.PointRoi(bgSubtractedImgStats.xCenterOfMass, bgSubtractedImgStats.yCenterOfMass);
imgBgSubtracted.setRoi(centerOfMassPt);
imgBgSubtracted.show();



// show image center point
r = ip.getRoi();
pos = new ij.gui.PointRoi(bgSubtractedImgStats.xCenterOfMass + r.getX(), bgSubtractedImgStats.yCenterOfMass + r.getY());
img.setRoi(pos);

// stage command logic
centerX = pos.getXBase() <= width / 2.0 ? width / 3 : width * (2.0 /3.0); 
centerY = height / 2.0;
print("CENTER");
print(centerX);
print(centerY);


xDistFromCenter = centerX - pos.getXBase();
yDistFromCenter = centerY - pos.getYBase();

print("DIST FROM CENTER");
print(xDistFromCenter);
print(yDistFromCenter);
distScalar = Math.sqrt((xDistFromCenter * xDistFromCenter) + (yDistFromCenter * yDistFromCenter));

int accelerationFactor = 1;
xVelocity = Math.round(-xDistFromCenter * accelerationFactor * 0.0018 * 1000.0) / 1000.0;
yVelocity = Math.round(yDistFromCenter * accelerationFactor * 0.0018 * 1000.0) / 1000.0;

stageVelocityCommand = "VECTOR X=" + String.valueOf(xVelocity) + " Y=" + String.valueOf(yVelocity);

print(stageVelocityCommand);
